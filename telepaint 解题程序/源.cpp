#include<stdio.h>
//先一步步针对特定的关卡进行编写程序


int main() {
	int site[9][20] = { 0 };		//全局的初始化，这样出现多余的位置点的原因是：返回墙定义√
	int i, j, d = 0;//√


	for (j = 1;j <= 19;j++) {//1到19
		site[2][j] = 1;
	}								//对有效地址的幅值
	site[2][19] = 100;				//胜利的原点，现阶段不考虑此位点可变√

									//site[1][6] = site[2][14] = 50;	//初始值的定义，


									//数值定义	0，无效地址；1，有效地址；#，人员现在所处的位置；50，可以互通；100，通关地址
	i = 2;j = 3;//初始化定位值
	int r = 0, l = 0;


	for (;site[i][j] != 0;j++, r++) //不考虑上下位置变化，如何引入site
	{
		if (site[i][j] == 100)
		{
			printf("向右走%d步后成功到达！\n", r);
			goto over;
		}
		void;
		//site[i][j] = 1;


	}

	for (;site[i][j] != 0;j--, l++) //不考虑上下位置变化，如何引入site
	{
		if (site[i][j] == 100)
		{
			printf("先向右走%d步，再向左走%d步后成功到达！\n", r, l);
			goto over;
		}
		void;
		//site[i][j] = 1;

	}

over:while (1);
	return 0;
}


/*
运行日志：
1，第一次出现死循环，修改
2，第二次出现里面的数值重新优化，新增一些多余位置点用于反向判别
3，优化程序，使用goto语句最简单的模型可以完成了yeah
4，出现反向bug，进行程序review


*/
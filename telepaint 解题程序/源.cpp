#include<stdio.h>
//先一步步针对特定的关卡进行编写程序


int main() {
	int site[9][20] = { 0 };		//全局的初始化，这样出现多余的位置点的原因是：返回墙定义√
	int i, j, d = 0;//√


	for (j = 1;j <= 19;j++) {//1到19
		site[1][j] = 1;
	}								//对有效地址的幅值
	site[1][19] = 100;				//胜利的原点，现阶段不考虑此位点可变√
	//site[1][1] = 100;				//第二种情况

									//site[1][6] = site[2][14] = 50;	//初始值的定义，


									//数值定义	0，无效地址；1，有效地址；#，人员现在所处的位置；50，可以互通；100，通关地址
	//i = 2;j = 3;//初始化定位值
	int r = 0, l = 0;//左右两个方向的位移记录


	for (i=1,j=10;site[i][j] != 0;j++, r++) //不考虑上下位置变化，如何引入site
	{
		if (site[i][j] == 100)
		{
			printf("向右走%d步后成功到达！\n", r);
			goto over;
		}
		//void;
		//site[i][j] = 1;


	}

	for (i = 1,j=19 ; site[i][j] != 0; j--, l++) //不考虑上下位置变化，如何引入site
	{
		if (site[i][j] == 100)
		{
			printf("先向右走%d步，再向左走%d步后成功到达！\n", r, l);
			goto over;
		}
		//void;
		//site[i][j] = 1;

	}

over:while (1);
	return 0;
}


/*
建立模型：
最简单模型，1,1到 1,19都是可行的，其它位置点屏蔽掉
起始位置为1,10
情况1；终点为1,19
情况2；终点为1,1

运行日志：
1，第一次出现死循环，修改
2，第二次出现里面的数值重新优化，新增一些多余位置点用于反向判别
3，优化程序，使用goto语句最简单的模型可以完成了yeah
4，出现反向bug，进行程序review
5，反向的情况得以实现	2017.07.02	21：35

模型一	完成（√）
*/